#ifndef REP_ENGINE_MERGED_H
#define REP_ENGINE_MERGED_H

// This is an autogenerated file.
// Do not edit this file, any changes made will be lost the next time it is generated.

#include <QtCore/qobject.h>
#include <QtCore/qdatastream.h>
#include <QtCore/qvariant.h>
#include <QtCore/qmetatype.h>

#include <QtRemoteObjects/qremoteobjectnode.h>
#include <QtRemoteObjects/qremoteobjectpendingcall.h>
#include <QtRemoteObjects/qremoteobjectreplica.h>
#include <QtRemoteObjects/qremoteobjectsource.h>

#include "temperature.h"

class EngineReplica : public QRemoteObjectReplica
{
    Q_OBJECT
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, "Engine")
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_SIGNATURE, "251e6cd1e5d8070a848b9f195be8bde5a0fb488d")
    Q_PROPERTY(int cylinders READ cylinders CONSTANT)
    Q_PROPERTY(bool started READ started NOTIFY startedChanged)
    Q_PROPERTY(int rpm READ rpm WRITE setRpm NOTIFY rpmChanged)
    Q_PROPERTY(EngineType engineType READ engineType NOTIFY engineTypeChanged)

public:
    enum EngineType {
        GAS = 0,
        ELECTRIC = 1,
        HYBRID = 2,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(EngineType)
#else
    Q_ENUMS(EngineType)
#endif

public:
    EngineReplica() : QRemoteObjectReplica() { initialize(); }
    static void registerMetatypes()
    {
        static bool initialized = false;
        if (initialized)
            return;
        initialized = true;
        qRegisterMetaType<EngineType>();
        qRegisterMetaTypeStreamOperators<EngineType>();
        qRegisterMetaType<Temperature>();
        qRegisterMetaTypeStreamOperators<Temperature>();
        qRegisterMetaType<Temperature::Ptr>();
        qRegisterMetaTypeStreamOperators<Temperature::Ptr>();

    }

private:
    EngineReplica(QRemoteObjectNode *node, const QString &name = QString())
        : QRemoteObjectReplica(ConstructWithNode)
        { initializeNode(node, name); }

    void initialize()
    {
        EngineReplica::registerMetatypes();
        QVariantList properties;
        properties.reserve(4);
        properties << QVariant::fromValue(int(4));
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(EngineType(GAS));
        QVariantList stored = retrieveProperties("Engine", "251e6cd1e5d8070a848b9f195be8bde5a0fb488d");
        if (!stored.isEmpty()) {
            properties[3] = stored.at(0);
        }
        setProperties(properties);
    }

public:
    virtual ~EngineReplica() {
        QVariantList persisted;
        persisted << propAsVariant(3);
        persistProperties("Engine", "251e6cd1e5d8070a848b9f195be8bde5a0fb488d", persisted);
    }

    static inline EngineType toEngineType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return GAS;
        case 1: return ELECTRIC;
        case 2: return HYBRID;
        default:
            if (ok)
                *ok = false;
            return GAS;
        }
    }
    int cylinders() const
    {
        const QVariant variant = propAsVariant(0);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property cylinders to type int";
        }
        return variant.value<int >();
    }

    bool started() const
    {
        const QVariant variant = propAsVariant(1);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property started to type bool";
        }
        return variant.value<bool >();
    }

    int rpm() const
    {
        const QVariant variant = propAsVariant(2);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property rpm to type int";
        }
        return variant.value<int >();
    }

    void setRpm(int rpm)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfProperty("rpm");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(rpm);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    EngineType engineType() const
    {
        const QVariant variant = propAsVariant(3);
        if (!variant.canConvert<EngineType>()) {
            qWarning() << "QtRO cannot convert the property engineType to type EngineType";
        }
        return variant.value<EngineType >();
    }


Q_SIGNALS:
    void startedChanged(bool);
    void rpmChanged(int);
    void engineTypeChanged(EngineReplica::EngineType);

public Q_SLOTS:
    void pushStarted(bool started)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("pushStarted(bool)");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(started);
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void pushEngineType(EngineType engineType)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("pushEngineType(EngineType)");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(engineType);
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    QRemoteObjectPendingReply<bool> start()
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("start()");
        QVariantList __repc_args;
        return QRemoteObjectPendingReply<bool>(sendWithReply(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args));
    }
    void increaseRpm(int deltaRpm)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("increaseRpm(int)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(deltaRpm)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void unnormalizedSignature(int a, int b)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("unnormalizedSignature(int,int)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(a)
            << QVariant::fromValue(b)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    QRemoteObjectPendingReply<Temperature> temperature()
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("temperature()");
        QVariantList __repc_args;
        return QRemoteObjectPendingReply<Temperature>(sendWithReply(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args));
    }
    void setSharedTemperature(const Temperature::Ptr & sharedTemperature)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("setSharedTemperature(Temperature::Ptr)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(sharedTemperature)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    QRemoteObjectPendingReply<QString> myTestString()
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("myTestString()");
        QVariantList __repc_args;
        return QRemoteObjectPendingReply<QString>(sendWithReply(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args));
    }
    void setMyTestString(QString value)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("setMyTestString(QString)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(value)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }

private:
    friend class QT_PREPEND_NAMESPACE(QRemoteObjectNode);
};

#if (QT_VERSION < QT_VERSION_CHECK(5, 5, 0))
    Q_DECLARE_METATYPE(EngineReplica::EngineType)
#endif

inline QDataStream &operator<<(QDataStream &ds, const EngineReplica::EngineType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, EngineReplica::EngineType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = EngineReplica::toEngineType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeEngineType, value =" << val;
    return ds;
}


class EngineSource : public QObject
{
    Q_OBJECT
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, "Engine")
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_SIGNATURE, "251e6cd1e5d8070a848b9f195be8bde5a0fb488d")
    Q_PROPERTY(int cylinders READ cylinders CONSTANT)
    Q_PROPERTY(bool started READ started WRITE setStarted NOTIFY startedChanged)
    Q_PROPERTY(int rpm READ rpm WRITE setRpm NOTIFY rpmChanged)
    Q_PROPERTY(EngineType engineType READ engineType WRITE setEngineType NOTIFY engineTypeChanged)

public:
    enum EngineType {
        GAS = 0,
        ELECTRIC = 1,
        HYBRID = 2,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(EngineType)
#else
    Q_ENUMS(EngineType)
#endif

public:
    explicit EngineSource(QObject *parent = nullptr) : QObject(parent)
    {
        qRegisterMetaType<EngineType>();
        qRegisterMetaTypeStreamOperators<EngineType>();
        qRegisterMetaType<Temperature>();
        qRegisterMetaTypeStreamOperators<Temperature>();
        qRegisterMetaType<Temperature::Ptr>();
        qRegisterMetaTypeStreamOperators<Temperature::Ptr>();

    }

public:
    virtual ~EngineSource() {}

    static inline EngineType toEngineType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return GAS;
        case 1: return ELECTRIC;
        case 2: return HYBRID;
        default:
            if (ok)
                *ok = false;
            return GAS;
        }
    }
    virtual int cylinders() const = 0;
    virtual bool started() const = 0;
    virtual int rpm() const = 0;
    virtual EngineType engineType() const = 0;
    virtual void setStarted(bool started) = 0;
    virtual void setRpm(int rpm) = 0;
    virtual void setEngineType(EngineType engineType) = 0;

Q_SIGNALS:
    void startedChanged(bool);
    void rpmChanged(int);
    void engineTypeChanged(EngineSource::EngineType);

public Q_SLOTS:
    virtual void pushStarted(bool started)
    {
        setStarted(started);
    }
    virtual void pushEngineType(EngineType engineType)
    {
        setEngineType(engineType);
    }
    virtual bool start() = 0;
    virtual void increaseRpm(int deltaRpm) = 0;
    virtual void unnormalizedSignature(int a, int b) = 0;
    virtual Temperature temperature() = 0;
    virtual void setSharedTemperature(const Temperature::Ptr & sharedTemperature) = 0;
    virtual QString myTestString() = 0;
    virtual void setMyTestString(QString value) = 0;

private:
    friend class QT_PREPEND_NAMESPACE(QRemoteObjectNode);
};

#if (QT_VERSION < QT_VERSION_CHECK(5, 5, 0))
    Q_DECLARE_METATYPE(EngineSource::EngineType)
#endif

inline QDataStream &operator<<(QDataStream &ds, const EngineSource::EngineType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, EngineSource::EngineType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = EngineSource::toEngineType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeEngineType, value =" << val;
    return ds;
}


class EngineSimpleSource : public QObject
{
    Q_OBJECT
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, "Engine")
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_SIGNATURE, "251e6cd1e5d8070a848b9f195be8bde5a0fb488d")
    Q_PROPERTY(int cylinders READ cylinders CONSTANT)
    Q_PROPERTY(bool started READ started WRITE setStarted NOTIFY startedChanged)
    Q_PROPERTY(int rpm READ rpm WRITE setRpm NOTIFY rpmChanged)
    Q_PROPERTY(EngineType engineType READ engineType WRITE setEngineType NOTIFY engineTypeChanged)

public:
    enum EngineType {
        GAS = 0,
        ELECTRIC = 1,
        HYBRID = 2,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(EngineType)
#else
    Q_ENUMS(EngineType)
#endif

public:
    explicit EngineSimpleSource(QObject *parent = nullptr) : QObject(parent)
        , _cylinders(4)
        , _started()
        , _rpm()
        , _engineType(GAS)
    {
        qRegisterMetaType<EngineType>();
        qRegisterMetaTypeStreamOperators<EngineType>();
        qRegisterMetaType<Temperature>();
        qRegisterMetaTypeStreamOperators<Temperature>();
        qRegisterMetaType<Temperature::Ptr>();
        qRegisterMetaTypeStreamOperators<Temperature::Ptr>();

    }

public:
    virtual ~EngineSimpleSource() {}

    static inline EngineType toEngineType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return GAS;
        case 1: return ELECTRIC;
        case 2: return HYBRID;
        default:
            if (ok)
                *ok = false;
            return GAS;
        }
    }
    virtual int cylinders() const { return _cylinders; }
    virtual bool started() const { return _started; }
    virtual int rpm() const { return _rpm; }
    virtual EngineType engineType() const { return _engineType; }
    virtual void setStarted(bool started)
    {
        if (started != _started) { 
            _started = started;
            Q_EMIT startedChanged(_started);
        }
    }
    virtual void setRpm(int rpm)
    {
        if (rpm != _rpm) { 
            _rpm = rpm;
            Q_EMIT rpmChanged(_rpm);
        }
    }
    virtual void setEngineType(EngineType engineType)
    {
        if (engineType != _engineType) { 
            _engineType = engineType;
            Q_EMIT engineTypeChanged(_engineType);
        }
    }

Q_SIGNALS:
    void startedChanged(bool);
    void rpmChanged(int);
    void engineTypeChanged(EngineSimpleSource::EngineType);

public Q_SLOTS:
    virtual void pushStarted(bool started)
    {
        setStarted(started);
    }
    virtual void pushEngineType(EngineType engineType)
    {
        setEngineType(engineType);
    }
    virtual bool start() = 0;
    virtual void increaseRpm(int deltaRpm) = 0;
    virtual void unnormalizedSignature(int a, int b) = 0;
    virtual Temperature temperature() = 0;
    virtual void setSharedTemperature(const Temperature::Ptr & sharedTemperature) = 0;
    virtual QString myTestString() = 0;
    virtual void setMyTestString(QString value) = 0;

private:
    int _cylinders;
    bool _started;
    int _rpm;
    EngineType _engineType;

private:
    friend class QT_PREPEND_NAMESPACE(QRemoteObjectNode);
};

#if (QT_VERSION < QT_VERSION_CHECK(5, 5, 0))
    Q_DECLARE_METATYPE(EngineSimpleSource::EngineType)
#endif

inline QDataStream &operator<<(QDataStream &ds, const EngineSimpleSource::EngineType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, EngineSimpleSource::EngineType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = EngineSimpleSource::toEngineType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeEngineType, value =" << val;
    return ds;
}


template <class ObjectType>
struct EngineSourceAPI : public SourceApiMap
{
    // You need to add this enum as well as Q_ENUM to your
    // QObject class in order to use .rep enums over QtRO for
    // non-repc generated QObjects.
    enum EngineType {
        GAS = 0,
        ELECTRIC = 1,
        HYBRID = 2,
    };
    EngineSourceAPI(ObjectType *object)
        : SourceApiMap()
    {
        Q_UNUSED(object);
        _properties[0] = 4;
        _properties[1] = qtro_prop_index<ObjectType>(&ObjectType::cylinders, static_cast<int (QObject::*)()>(0),"cylinders");
        _properties[2] = qtro_prop_index<ObjectType>(&ObjectType::started, static_cast<bool (QObject::*)()>(0),"started");
        qtro_method_test<ObjectType>(&ObjectType::startedChanged, static_cast<void (QObject::*)()>(0));
        _properties[3] = qtro_prop_index<ObjectType>(&ObjectType::rpm, static_cast<int (QObject::*)()>(0),"rpm");
        qtro_method_test<ObjectType>(&ObjectType::setRpm, static_cast<void (QObject::*)(int)>(0));
        qtro_method_test<ObjectType>(&ObjectType::rpmChanged, static_cast<void (QObject::*)()>(0));
        _properties[4] = qtro_prop_index<ObjectType>(&ObjectType::engineType, static_cast<typename ObjectType::EngineType (QObject::*)()>(0),"engineType");
        qtro_method_test<ObjectType>(&ObjectType::engineTypeChanged, static_cast<void (QObject::*)()>(0));
        _signals[0] = 3;
        _signals[1] = qtro_signal_index<ObjectType>(&ObjectType::startedChanged, static_cast<void (QObject::*)()>(0),signalArgCount+0,&signalArgTypes[0]);
        _signals[2] = qtro_signal_index<ObjectType>(&ObjectType::rpmChanged, static_cast<void (QObject::*)()>(0),signalArgCount+1,&signalArgTypes[1]);
        _signals[3] = qtro_signal_index<ObjectType>(&ObjectType::engineTypeChanged, static_cast<void (QObject::*)()>(0),signalArgCount+2,&signalArgTypes[2]);
        _methods[0] = 9;
        _methods[1] = qtro_method_index<ObjectType>(&ObjectType::pushStarted, static_cast<void (QObject::*)(bool)>(0),"pushStarted(bool)",methodArgCount+0,&methodArgTypes[0]);
        _methods[2] = qtro_method_index<ObjectType>(&ObjectType::pushEngineType, static_cast<void (QObject::*)(typename ObjectType::EngineType)>(0),"pushEngineType(typename ObjectType::EngineType)",methodArgCount+1,&methodArgTypes[1]);
        _methods[3] = qtro_method_index<ObjectType>(&ObjectType::start, static_cast<void (QObject::*)()>(0),"start()",methodArgCount+2,&methodArgTypes[2]);
        _methods[4] = qtro_method_index<ObjectType>(&ObjectType::increaseRpm, static_cast<void (QObject::*)(int)>(0),"increaseRpm(int)",methodArgCount+3,&methodArgTypes[3]);
        _methods[5] = qtro_method_index<ObjectType>(&ObjectType::unnormalizedSignature, static_cast<void (QObject::*)(int,int)>(0),"unnormalizedSignature(int,int)",methodArgCount+4,&methodArgTypes[4]);
        _methods[6] = qtro_method_index<ObjectType>(&ObjectType::temperature, static_cast<void (QObject::*)()>(0),"temperature()",methodArgCount+5,&methodArgTypes[5]);
        _methods[7] = qtro_method_index<ObjectType>(&ObjectType::setSharedTemperature, static_cast<void (QObject::*)(Temperature::Ptr)>(0),"setSharedTemperature(Temperature::Ptr)",methodArgCount+6,&methodArgTypes[6]);
        _methods[8] = qtro_method_index<ObjectType>(&ObjectType::myTestString, static_cast<void (QObject::*)()>(0),"myTestString()",methodArgCount+7,&methodArgTypes[7]);
        _methods[9] = qtro_method_index<ObjectType>(&ObjectType::setMyTestString, static_cast<void (QObject::*)(QString)>(0),"setMyTestString(QString)",methodArgCount+8,&methodArgTypes[8]);
        _modelCount = 0;
    }

    QString name() const override { return QStringLiteral("Engine"); }
    QString typeName() const override { return QStringLiteral("Engine"); }
    int propertyCount() const override { return _properties[0]; }
    int signalCount() const override { return _signals[0]; }
    int methodCount() const override { return _methods[0]; }
    int modelCount() const override { return _modelCount; }
    int sourcePropertyIndex(int index) const override
    {
        if (index < 0 || index >= _properties[0])
            return -1;
        return _properties[index+1];
    }
    int sourceSignalIndex(int index) const override
    {
        if (index < 0 || index >= _signals[0])
            return -1;
        return _signals[index+1];
    }
    int sourceMethodIndex(int index) const override
    {
        if (index < 0 || index >= _methods[0])
            return -1;
        return _methods[index+1];
    }
    int signalParameterCount(int index) const override
    {
        if (index < 0 || index >= _signals[0])
            return -1;
        return signalArgCount[index];
    }
    int signalParameterType(int sigIndex, int paramIndex) const override
    {
        if (sigIndex < 0 || sigIndex >= _signals[0] || paramIndex < 0 || paramIndex >= signalArgCount[sigIndex])
            return -1;
        return signalArgTypes[sigIndex][paramIndex];
    }
    int methodParameterCount(int index) const override
    {
        if (index < 0 || index >= _methods[0])
            return -1;
        return methodArgCount[index];
    }
    int methodParameterType(int methodIndex, int paramIndex) const override
    {
        if (methodIndex < 0 || methodIndex >= _methods[0] || paramIndex < 0 || paramIndex >= methodArgCount[methodIndex])
            return -1;
        return methodArgTypes[methodIndex][paramIndex];
    }
    int propertyIndexFromSignal(int index) const override
    {
        switch (index) {
        case 0: return _properties[2];
        case 1: return _properties[3];
        case 2: return _properties[4];
        }
        return -1;
    }
    int propertyRawIndexFromSignal(int index) const override
    {
        switch (index) {
        case 0: return 2;
        case 1: return 3;
        case 2: return 4;
        }
        return -1;
    }
    const QByteArray signalSignature(int index) const override
    {
        switch (index) {
        case 0: return QByteArrayLiteral("startedChanged()");
        case 1: return QByteArrayLiteral("rpmChanged()");
        case 2: return QByteArrayLiteral("engineTypeChanged()");
        }
        return QByteArrayLiteral("");
    }
    const QByteArray methodSignature(int index) const override
    {
        switch (index) {
        case 0: return QByteArrayLiteral("pushStarted(bool)");
        case 1: return QByteArrayLiteral("pushEngineType(EngineType)");
        case 2: return QByteArrayLiteral("start()");
        case 3: return QByteArrayLiteral("increaseRpm(int)");
        case 4: return QByteArrayLiteral("unnormalizedSignature(int,int)");
        case 5: return QByteArrayLiteral("temperature()");
        case 6: return QByteArrayLiteral("setSharedTemperature(Temperature::Ptr)");
        case 7: return QByteArrayLiteral("myTestString()");
        case 8: return QByteArrayLiteral("setMyTestString(QString)");
        }
        return QByteArrayLiteral("");
    }
    QMetaMethod::MethodType methodType(int) const override
    {
        return QMetaMethod::Slot;
    }
    const QByteArray typeName(int index) const override
    {
        switch (index) {
        case 0: return QByteArrayLiteral("void");
        case 1: return QByteArrayLiteral("void");
        case 2: return QByteArrayLiteral("bool");
        case 3: return QByteArrayLiteral("void");
        case 4: return QByteArrayLiteral("void");
        case 5: return QByteArrayLiteral("Temperature");
        case 6: return QByteArrayLiteral("void");
        case 7: return QByteArrayLiteral("QString");
        case 8: return QByteArrayLiteral("void");
        }
        return QByteArrayLiteral("");
    }
    QByteArray objectSignature() const override { return QByteArray{"251e6cd1e5d8070a848b9f195be8bde5a0fb488d"}; }

    int _properties[5];
    int _signals[4];
    int _methods[10];
    int signalArgCount[3];
    const int* signalArgTypes[3];
    int methodArgCount[9];
    const int* methodArgTypes[9];
    int _modelCount;
};
QT_BEGIN_NAMESPACE
QT_END_NAMESPACE


#endif // REP_ENGINE_MERGED_H
