#ifndef REP_ENGINE_REPLICA_H
#define REP_ENGINE_REPLICA_H

// This is an autogenerated file.
// Do not edit this file, any changes made will be lost the next time it is generated.

#include <QtCore/qobject.h>
#include <QtCore/qdatastream.h>
#include <QtCore/qvariant.h>
#include <QtCore/qmetatype.h>

#include <QtRemoteObjects/qremoteobjectnode.h>
#include <QtRemoteObjects/qremoteobjectpendingcall.h>
#include <QtRemoteObjects/qremoteobjectreplica.h>

#include "temperature.h"

class EngineReplica : public QRemoteObjectReplica
{
    Q_OBJECT
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, "Engine")
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_SIGNATURE, "251e6cd1e5d8070a848b9f195be8bde5a0fb488d")
    Q_PROPERTY(int cylinders READ cylinders CONSTANT)
    Q_PROPERTY(bool started READ started NOTIFY startedChanged)
    Q_PROPERTY(int rpm READ rpm WRITE setRpm NOTIFY rpmChanged)
    Q_PROPERTY(EngineType engineType READ engineType NOTIFY engineTypeChanged)

public:
    enum EngineType {
        GAS = 0,
        ELECTRIC = 1,
        HYBRID = 2,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(EngineType)
#else
    Q_ENUMS(EngineType)
#endif

public:
    EngineReplica() : QRemoteObjectReplica() { initialize(); }
    static void registerMetatypes()
    {
        static bool initialized = false;
        if (initialized)
            return;
        initialized = true;
        qRegisterMetaType<Temperature>();
        qRegisterMetaTypeStreamOperators<Temperature>();
        qRegisterMetaType<EngineType>();
        qRegisterMetaTypeStreamOperators<EngineType>();
        qRegisterMetaType<Temperature::Ptr>();
        qRegisterMetaTypeStreamOperators<Temperature::Ptr>();

    }

private:
    EngineReplica(QRemoteObjectNode *node, const QString &name = QString())
        : QRemoteObjectReplica(ConstructWithNode)
        { initializeNode(node, name); }

    void initialize()
    {
        EngineReplica::registerMetatypes();
        QVariantList properties;
        properties.reserve(4);
        properties << QVariant::fromValue(int(4));
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(EngineType(GAS));
        QVariantList stored = retrieveProperties("Engine", "251e6cd1e5d8070a848b9f195be8bde5a0fb488d");
        if (!stored.isEmpty()) {
            properties[3] = stored.at(0);
        }
        setProperties(properties);
    }

public:
    virtual ~EngineReplica() {
        QVariantList persisted;
        persisted << propAsVariant(3);
        persistProperties("Engine", "251e6cd1e5d8070a848b9f195be8bde5a0fb488d", persisted);
    }

    static inline EngineType toEngineType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return GAS;
        case 1: return ELECTRIC;
        case 2: return HYBRID;
        default:
            if (ok)
                *ok = false;
            return GAS;
        }
    }
    int cylinders() const
    {
        const QVariant variant = propAsVariant(0);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property cylinders to type int";
        }
        return variant.value<int >();
    }

    bool started() const
    {
        const QVariant variant = propAsVariant(1);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property started to type bool";
        }
        return variant.value<bool >();
    }

    int rpm() const
    {
        const QVariant variant = propAsVariant(2);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property rpm to type int";
        }
        return variant.value<int >();
    }

    void setRpm(int rpm)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfProperty("rpm");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(rpm);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    EngineType engineType() const
    {
        const QVariant variant = propAsVariant(3);
        if (!variant.canConvert<EngineType>()) {
            qWarning() << "QtRO cannot convert the property engineType to type EngineType";
        }
        return variant.value<EngineType >();
    }


Q_SIGNALS:
    void startedChanged(bool);
    void rpmChanged(int);
    void engineTypeChanged(EngineReplica::EngineType);

public Q_SLOTS:
    void pushStarted(bool started)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("pushStarted(bool)");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(started);
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void pushEngineType(EngineType engineType)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("pushEngineType(EngineType)");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(engineType);
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    QRemoteObjectPendingReply<bool> start()
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("start()");
        QVariantList __repc_args;
        return QRemoteObjectPendingReply<bool>(sendWithReply(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args));
    }
    void increaseRpm(int deltaRpm)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("increaseRpm(int)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(deltaRpm)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void unnormalizedSignature(int a, int b)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("unnormalizedSignature(int,int)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(a)
            << QVariant::fromValue(b)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    QRemoteObjectPendingReply<Temperature> temperature()
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("temperature()");
        QVariantList __repc_args;
        return QRemoteObjectPendingReply<Temperature>(sendWithReply(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args));
    }
    void setSharedTemperature(const Temperature::Ptr & sharedTemperature)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("setSharedTemperature(Temperature::Ptr)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(sharedTemperature)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    QRemoteObjectPendingReply<QString> myTestString()
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("myTestString()");
        QVariantList __repc_args;
        return QRemoteObjectPendingReply<QString>(sendWithReply(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args));
    }
    void setMyTestString(QString value)
    {
        static int __repc_index = EngineReplica::staticMetaObject.indexOfSlot("setMyTestString(QString)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(value)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }

private:
    friend class QT_PREPEND_NAMESPACE(QRemoteObjectNode);
};

#if (QT_VERSION < QT_VERSION_CHECK(5, 5, 0))
    Q_DECLARE_METATYPE(EngineReplica::EngineType)
#endif

inline QDataStream &operator<<(QDataStream &ds, const EngineReplica::EngineType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, EngineReplica::EngineType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = EngineReplica::toEngineType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeEngineType, value =" << val;
    return ds;
}


QT_BEGIN_NAMESPACE
QT_END_NAMESPACE


#endif // REP_ENGINE_REPLICA_H
