/****************************************************************************
** Meta object code from reading C++ file 'tst_qqmlmetatype.cpp'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.9.6)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'tst_qqmlmetatype.cpp' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.9.6. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_tst_qqmlmetatype_t {
    QByteArrayData data[16];
    char stringdata0[269];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_tst_qqmlmetatype_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_tst_qqmlmetatype_t qt_meta_stringdata_tst_qqmlmetatype = {
    {
QT_MOC_LITERAL(0, 0, 16), // "tst_qqmlmetatype"
QT_MOC_LITERAL(1, 17, 12), // "initTestCase"
QT_MOC_LITERAL(2, 30, 0), // ""
QT_MOC_LITERAL(3, 31, 19), // "qmlParserStatusCast"
QT_MOC_LITERAL(4, 51, 26), // "qmlPropertyValueSourceCast"
QT_MOC_LITERAL(5, 78, 31), // "qmlPropertyValueInterceptorCast"
QT_MOC_LITERAL(6, 110, 7), // "qmlType"
QT_MOC_LITERAL(7, 118, 18), // "invalidQmlTypeName"
QT_MOC_LITERAL(8, 137, 14), // "prettyTypeName"
QT_MOC_LITERAL(9, 152, 16), // "registrationType"
QT_MOC_LITERAL(10, 169, 13), // "compositeType"
QT_MOC_LITERAL(11, 183, 13), // "externalEnums"
QT_MOC_LITERAL(12, 197, 6), // "isList"
QT_MOC_LITERAL(13, 204, 13), // "defaultObject"
QT_MOC_LITERAL(14, 218, 20), // "unregisterCustomType"
QT_MOC_LITERAL(15, 239, 29) // "unregisterCustomSingletonType"

    },
    "tst_qqmlmetatype\0initTestCase\0\0"
    "qmlParserStatusCast\0qmlPropertyValueSourceCast\0"
    "qmlPropertyValueInterceptorCast\0qmlType\0"
    "invalidQmlTypeName\0prettyTypeName\0"
    "registrationType\0compositeType\0"
    "externalEnums\0isList\0defaultObject\0"
    "unregisterCustomType\0unregisterCustomSingletonType"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_tst_qqmlmetatype[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
      14,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags
       1,    0,   84,    2, 0x08 /* Private */,
       3,    0,   85,    2, 0x08 /* Private */,
       4,    0,   86,    2, 0x08 /* Private */,
       5,    0,   87,    2, 0x08 /* Private */,
       6,    0,   88,    2, 0x08 /* Private */,
       7,    0,   89,    2, 0x08 /* Private */,
       8,    0,   90,    2, 0x08 /* Private */,
       9,    0,   91,    2, 0x08 /* Private */,
      10,    0,   92,    2, 0x08 /* Private */,
      11,    0,   93,    2, 0x08 /* Private */,
      12,    0,   94,    2, 0x08 /* Private */,
      13,    0,   95,    2, 0x08 /* Private */,
      14,    0,   96,    2, 0x08 /* Private */,
      15,    0,   97,    2, 0x08 /* Private */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

void tst_qqmlmetatype::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        tst_qqmlmetatype *_t = static_cast<tst_qqmlmetatype *>(_o);
        Q_UNUSED(_t)
        switch (_id) {
        case 0: _t->initTestCase(); break;
        case 1: _t->qmlParserStatusCast(); break;
        case 2: _t->qmlPropertyValueSourceCast(); break;
        case 3: _t->qmlPropertyValueInterceptorCast(); break;
        case 4: _t->qmlType(); break;
        case 5: _t->invalidQmlTypeName(); break;
        case 6: _t->prettyTypeName(); break;
        case 7: _t->registrationType(); break;
        case 8: _t->compositeType(); break;
        case 9: _t->externalEnums(); break;
        case 10: _t->isList(); break;
        case 11: _t->defaultObject(); break;
        case 12: _t->unregisterCustomType(); break;
        case 13: _t->unregisterCustomSingletonType(); break;
        default: ;
        }
    }
    Q_UNUSED(_a);
}

const QMetaObject tst_qqmlmetatype::staticMetaObject = {
    { &QQmlDataTest::staticMetaObject, qt_meta_stringdata_tst_qqmlmetatype.data,
      qt_meta_data_tst_qqmlmetatype,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *tst_qqmlmetatype::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *tst_qqmlmetatype::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_tst_qqmlmetatype.stringdata0))
        return static_cast<void*>(this);
    return QQmlDataTest::qt_metacast(_clname);
}

int tst_qqmlmetatype::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QQmlDataTest::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 14)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 14;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 14)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 14;
    }
    return _id;
}
struct qt_meta_stringdata_TestType_t {
    QByteArrayData data[3];
    char stringdata0[29];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_TestType_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_TestType_t qt_meta_stringdata_TestType = {
    {
QT_MOC_LITERAL(0, 0, 8), // "TestType"
QT_MOC_LITERAL(1, 9, 15), // "DefaultProperty"
QT_MOC_LITERAL(2, 25, 3) // "foo"

    },
    "TestType\0DefaultProperty\0foo"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_TestType[] = {

 // content:
       7,       // revision
       0,       // classname
       1,   14, // classinfo
       0,    0, // methods
       1,   16, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // classinfo: key, value
       1,    2,

 // properties: name, type, flags
       2, QMetaType::Int, 0x00095001,

       0        // eod
};

void TestType::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{

#ifndef QT_NO_PROPERTIES
    if (_c == QMetaObject::ReadProperty) {
        TestType *_t = static_cast<TestType *>(_o);
        Q_UNUSED(_t)
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< int*>(_v) = _t->foo(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
    } else if (_c == QMetaObject::ResetProperty) {
    }
#endif // QT_NO_PROPERTIES
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

const QMetaObject TestType::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_TestType.data,
      qt_meta_data_TestType,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *TestType::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *TestType::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_TestType.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int TestType::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    
#ifndef QT_NO_PROPERTIES
   if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::QueryPropertyDesignable) {
        _id -= 1;
    } else if (_c == QMetaObject::QueryPropertyScriptable) {
        _id -= 1;
    } else if (_c == QMetaObject::QueryPropertyStored) {
        _id -= 1;
    } else if (_c == QMetaObject::QueryPropertyEditable) {
        _id -= 1;
    } else if (_c == QMetaObject::QueryPropertyUser) {
        _id -= 1;
    }
#endif // QT_NO_PROPERTIES
    return _id;
}
struct qt_meta_stringdata_TestType2_t {
    QByteArrayData data[1];
    char stringdata0[10];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_TestType2_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_TestType2_t qt_meta_stringdata_TestType2 = {
    {
QT_MOC_LITERAL(0, 0, 9) // "TestType2"

    },
    "TestType2"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_TestType2[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void TestType2::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

const QMetaObject TestType2::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_TestType2.data,
      qt_meta_data_TestType2,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *TestType2::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *TestType2::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_TestType2.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int TestType2::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
struct qt_meta_stringdata_TestType3_t {
    QByteArrayData data[1];
    char stringdata0[10];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_TestType3_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_TestType3_t qt_meta_stringdata_TestType3 = {
    {
QT_MOC_LITERAL(0, 0, 9) // "TestType3"

    },
    "TestType3"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_TestType3[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void TestType3::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

const QMetaObject TestType3::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_TestType3.data,
      qt_meta_data_TestType3,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *TestType3::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *TestType3::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_TestType3.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int TestType3::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
struct qt_meta_stringdata_ExternalEnums_t {
    QByteArrayData data[1];
    char stringdata0[14];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_ExternalEnums_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_ExternalEnums_t qt_meta_stringdata_ExternalEnums = {
    {
QT_MOC_LITERAL(0, 0, 13) // "ExternalEnums"

    },
    "ExternalEnums"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_ExternalEnums[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // enums: name, flags, count, data

 // enum data: key, value

       0        // eod
};

void ExternalEnums::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

static const QMetaObject * const qt_meta_extradata_ExternalEnums[] = {
        &QStandardPaths::staticMetaObject,
    nullptr
};

const QMetaObject ExternalEnums::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_ExternalEnums.data,
      qt_meta_data_ExternalEnums,  qt_static_metacall, qt_meta_extradata_ExternalEnums, nullptr}
};


const QMetaObject *ExternalEnums::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *ExternalEnums::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_ExternalEnums.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int ExternalEnums::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
struct qt_meta_stringdata_ParserStatusTestType_t {
    QByteArrayData data[3];
    char stringdata0[41];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_ParserStatusTestType_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_ParserStatusTestType_t qt_meta_stringdata_ParserStatusTestType = {
    {
QT_MOC_LITERAL(0, 0, 20), // "ParserStatusTestType"
QT_MOC_LITERAL(1, 21, 15), // "DefaultProperty"
QT_MOC_LITERAL(2, 37, 3) // "foo"

    },
    "ParserStatusTestType\0DefaultProperty\0"
    "foo"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_ParserStatusTestType[] = {

 // content:
       7,       // revision
       0,       // classname
       1,   14, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // classinfo: key, value
       1,    2,

       0        // eod
};

void ParserStatusTestType::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

const QMetaObject ParserStatusTestType::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_ParserStatusTestType.data,
      qt_meta_data_ParserStatusTestType,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *ParserStatusTestType::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *ParserStatusTestType::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_ParserStatusTestType.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "QQmlParserStatus"))
        return static_cast< QQmlParserStatus*>(this);
    if (!strcmp(_clname, "org.qt-project.Qt.QQmlParserStatus"))
        return static_cast< QQmlParserStatus*>(this);
    return QObject::qt_metacast(_clname);
}

int ParserStatusTestType::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
struct qt_meta_stringdata_ValueSourceTestType_t {
    QByteArrayData data[1];
    char stringdata0[20];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_ValueSourceTestType_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_ValueSourceTestType_t qt_meta_stringdata_ValueSourceTestType = {
    {
QT_MOC_LITERAL(0, 0, 19) // "ValueSourceTestType"

    },
    "ValueSourceTestType"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_ValueSourceTestType[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void ValueSourceTestType::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

const QMetaObject ValueSourceTestType::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_ValueSourceTestType.data,
      qt_meta_data_ValueSourceTestType,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *ValueSourceTestType::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *ValueSourceTestType::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_ValueSourceTestType.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "QQmlPropertyValueSource"))
        return static_cast< QQmlPropertyValueSource*>(this);
    if (!strcmp(_clname, "org.qt-project.Qt.QQmlPropertyValueSource"))
        return static_cast< QQmlPropertyValueSource*>(this);
    return QObject::qt_metacast(_clname);
}

int ValueSourceTestType::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
struct qt_meta_stringdata_ValueInterceptorTestType_t {
    QByteArrayData data[1];
    char stringdata0[25];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_ValueInterceptorTestType_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_ValueInterceptorTestType_t qt_meta_stringdata_ValueInterceptorTestType = {
    {
QT_MOC_LITERAL(0, 0, 24) // "ValueInterceptorTestType"

    },
    "ValueInterceptorTestType"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_ValueInterceptorTestType[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void ValueInterceptorTestType::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

const QMetaObject ValueInterceptorTestType::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_ValueInterceptorTestType.data,
      qt_meta_data_ValueInterceptorTestType,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *ValueInterceptorTestType::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *ValueInterceptorTestType::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_ValueInterceptorTestType.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "QQmlPropertyValueInterceptor"))
        return static_cast< QQmlPropertyValueInterceptor*>(this);
    if (!strcmp(_clname, "org.qt-project.Qt.QQmlPropertyValueInterceptor"))
        return static_cast< QQmlPropertyValueInterceptor*>(this);
    return QObject::qt_metacast(_clname);
}

int ValueInterceptorTestType::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
struct qt_meta_stringdata_Controller1_t {
    QByteArrayData data[6];
    char stringdata0[69];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_Controller1_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_Controller1_t qt_meta_stringdata_Controller1 = {
    {
QT_MOC_LITERAL(0, 0, 11), // "Controller1"
QT_MOC_LITERAL(1, 12, 6), // "string"
QT_MOC_LITERAL(2, 19, 7), // "enumVal"
QT_MOC_LITERAL(3, 27, 15), // "Controller1Enum"
QT_MOC_LITERAL(4, 43, 12), // "ENUM_VALUE_1"
QT_MOC_LITERAL(5, 56, 12) // "ENUM_VALUE_2"

    },
    "Controller1\0string\0enumVal\0Controller1Enum\0"
    "ENUM_VALUE_1\0ENUM_VALUE_2"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_Controller1[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       2,   14, // properties
       1,   20, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QString, 0x00095003,
       2, 0x80000000 | 3, 0x0009500b,

 // enums: name, flags, count, data
       3, 0x0,    2,   24,

 // enum data: key, value
       4, uint(Controller1::ENUM_VALUE_1),
       5, uint(Controller1::ENUM_VALUE_2),

       0        // eod
};

void Controller1::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{

#ifndef QT_NO_PROPERTIES
    if (_c == QMetaObject::ReadProperty) {
        Controller1 *_t = static_cast<Controller1 *>(_o);
        Q_UNUSED(_t)
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QString*>(_v) = _t->m_string; break;
        case 1: *reinterpret_cast< Controller1Enum*>(_v) = _t->m_enumVal; break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        Controller1 *_t = static_cast<Controller1 *>(_o);
        Q_UNUSED(_t)
        void *_v = _a[0];
        switch (_id) {
        case 0:
            if (_t->m_string != *reinterpret_cast< QString*>(_v)) {
                _t->m_string = *reinterpret_cast< QString*>(_v);
            }
            break;
        case 1:
            if (_t->m_enumVal != *reinterpret_cast< Controller1Enum*>(_v)) {
                _t->m_enumVal = *reinterpret_cast< Controller1Enum*>(_v);
            }
            break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    }
#endif // QT_NO_PROPERTIES
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

const QMetaObject Controller1::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_Controller1.data,
      qt_meta_data_Controller1,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *Controller1::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *Controller1::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_Controller1.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int Controller1::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    
#ifndef QT_NO_PROPERTIES
   if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::QueryPropertyDesignable) {
        _id -= 2;
    } else if (_c == QMetaObject::QueryPropertyScriptable) {
        _id -= 2;
    } else if (_c == QMetaObject::QueryPropertyStored) {
        _id -= 2;
    } else if (_c == QMetaObject::QueryPropertyEditable) {
        _id -= 2;
    } else if (_c == QMetaObject::QueryPropertyUser) {
        _id -= 2;
    }
#endif // QT_NO_PROPERTIES
    return _id;
}
struct qt_meta_stringdata_Controller2_t {
    QByteArrayData data[6];
    char stringdata0[69];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_Controller2_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_Controller2_t qt_meta_stringdata_Controller2 = {
    {
QT_MOC_LITERAL(0, 0, 11), // "Controller2"
QT_MOC_LITERAL(1, 12, 6), // "string"
QT_MOC_LITERAL(2, 19, 7), // "enumVal"
QT_MOC_LITERAL(3, 27, 15), // "Controller2Enum"
QT_MOC_LITERAL(4, 43, 12), // "ENUM_VALUE_1"
QT_MOC_LITERAL(5, 56, 12) // "ENUM_VALUE_2"

    },
    "Controller2\0string\0enumVal\0Controller2Enum\0"
    "ENUM_VALUE_1\0ENUM_VALUE_2"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_Controller2[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       2,   14, // properties
       1,   20, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QString, 0x00095003,
       2, 0x80000000 | 3, 0x0009500b,

 // enums: name, flags, count, data
       3, 0x0,    2,   24,

 // enum data: key, value
       4, uint(Controller2::ENUM_VALUE_1),
       5, uint(Controller2::ENUM_VALUE_2),

       0        // eod
};

void Controller2::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{

#ifndef QT_NO_PROPERTIES
    if (_c == QMetaObject::ReadProperty) {
        Controller2 *_t = static_cast<Controller2 *>(_o);
        Q_UNUSED(_t)
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QString*>(_v) = _t->m_string; break;
        case 1: *reinterpret_cast< Controller2Enum*>(_v) = _t->m_enumVal; break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        Controller2 *_t = static_cast<Controller2 *>(_o);
        Q_UNUSED(_t)
        void *_v = _a[0];
        switch (_id) {
        case 0:
            if (_t->m_string != *reinterpret_cast< QString*>(_v)) {
                _t->m_string = *reinterpret_cast< QString*>(_v);
            }
            break;
        case 1:
            if (_t->m_enumVal != *reinterpret_cast< Controller2Enum*>(_v)) {
                _t->m_enumVal = *reinterpret_cast< Controller2Enum*>(_v);
            }
            break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    }
#endif // QT_NO_PROPERTIES
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

const QMetaObject Controller2::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_Controller2.data,
      qt_meta_data_Controller2,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *Controller2::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *Controller2::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_Controller2.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int Controller2::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    
#ifndef QT_NO_PROPERTIES
   if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::QueryPropertyDesignable) {
        _id -= 2;
    } else if (_c == QMetaObject::QueryPropertyScriptable) {
        _id -= 2;
    } else if (_c == QMetaObject::QueryPropertyStored) {
        _id -= 2;
    } else if (_c == QMetaObject::QueryPropertyEditable) {
        _id -= 2;
    } else if (_c == QMetaObject::QueryPropertyUser) {
        _id -= 2;
    }
#endif // QT_NO_PROPERTIES
    return _id;
}
struct qt_meta_stringdata_StaticProvider1_t {
    QByteArrayData data[3];
    char stringdata0[36];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_StaticProvider1_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_StaticProvider1_t qt_meta_stringdata_StaticProvider1 = {
    {
QT_MOC_LITERAL(0, 0, 15), // "StaticProvider1"
QT_MOC_LITERAL(1, 16, 18), // "singletonGetString"
QT_MOC_LITERAL(2, 35, 0) // ""

    },
    "StaticProvider1\0singletonGetString\0"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_StaticProvider1[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // methods: name, argc, parameters, tag, flags
       1,    0,   19,    2, 0x02 /* Public */,

 // methods: parameters
    QMetaType::QString,

       0        // eod
};

void StaticProvider1::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        StaticProvider1 *_t = static_cast<StaticProvider1 *>(_o);
        Q_UNUSED(_t)
        switch (_id) {
        case 0: { QString _r = _t->singletonGetString();
            if (_a[0]) *reinterpret_cast< QString*>(_a[0]) = std::move(_r); }  break;
        default: ;
        }
    }
}

const QMetaObject StaticProvider1::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_StaticProvider1.data,
      qt_meta_data_StaticProvider1,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *StaticProvider1::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *StaticProvider1::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_StaticProvider1.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int StaticProvider1::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 1;
    }
    return _id;
}
struct qt_meta_stringdata_StaticProvider2_t {
    QByteArrayData data[3];
    char stringdata0[36];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_StaticProvider2_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_StaticProvider2_t qt_meta_stringdata_StaticProvider2 = {
    {
QT_MOC_LITERAL(0, 0, 15), // "StaticProvider2"
QT_MOC_LITERAL(1, 16, 18), // "singletonGetString"
QT_MOC_LITERAL(2, 35, 0) // ""

    },
    "StaticProvider2\0singletonGetString\0"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_StaticProvider2[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // methods: name, argc, parameters, tag, flags
       1,    0,   19,    2, 0x02 /* Public */,

 // methods: parameters
    QMetaType::QString,

       0        // eod
};

void StaticProvider2::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        StaticProvider2 *_t = static_cast<StaticProvider2 *>(_o);
        Q_UNUSED(_t)
        switch (_id) {
        case 0: { QString _r = _t->singletonGetString();
            if (_a[0]) *reinterpret_cast< QString*>(_a[0]) = std::move(_r); }  break;
        default: ;
        }
    }
}

const QMetaObject StaticProvider2::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_StaticProvider2.data,
      qt_meta_data_StaticProvider2,  qt_static_metacall, nullptr, nullptr}
};


const QMetaObject *StaticProvider2::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *StaticProvider2::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_StaticProvider2.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int StaticProvider2::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE
