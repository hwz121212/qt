/****************************************************************************
** Meta object code from reading C++ file 'qdeclarativegeomap_p.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.9.6)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "../../5.9.6/QtLocation/private/qdeclarativegeomap_p.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#include <QtCore/QList>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'qdeclarativegeomap_p.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.9.6. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_QDeclarativeGeoMap_t {
    QByteArrayData data[92];
    char stringdata0[1499];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_QDeclarativeGeoMap_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_QDeclarativeGeoMap_t qt_meta_stringdata_QDeclarativeGeoMap = {
    {
QT_MOC_LITERAL(0, 0, 18), // "QDeclarativeGeoMap"
QT_MOC_LITERAL(1, 19, 13), // "pluginChanged"
QT_MOC_LITERAL(2, 33, 0), // ""
QT_MOC_LITERAL(3, 34, 31), // "QDeclarativeGeoServiceProvider*"
QT_MOC_LITERAL(4, 66, 6), // "plugin"
QT_MOC_LITERAL(5, 73, 16), // "zoomLevelChanged"
QT_MOC_LITERAL(6, 90, 9), // "zoomLevel"
QT_MOC_LITERAL(7, 100, 13), // "centerChanged"
QT_MOC_LITERAL(8, 114, 14), // "QGeoCoordinate"
QT_MOC_LITERAL(9, 129, 10), // "coordinate"
QT_MOC_LITERAL(10, 140, 20), // "activeMapTypeChanged"
QT_MOC_LITERAL(11, 161, 24), // "supportedMapTypesChanged"
QT_MOC_LITERAL(12, 186, 23), // "minimumZoomLevelChanged"
QT_MOC_LITERAL(13, 210, 23), // "maximumZoomLevelChanged"
QT_MOC_LITERAL(14, 234, 15), // "mapItemsChanged"
QT_MOC_LITERAL(15, 250, 12), // "errorChanged"
QT_MOC_LITERAL(16, 263, 22), // "copyrightLinkActivated"
QT_MOC_LITERAL(17, 286, 4), // "link"
QT_MOC_LITERAL(18, 291, 24), // "copyrightsVisibleChanged"
QT_MOC_LITERAL(19, 316, 7), // "visible"
QT_MOC_LITERAL(20, 324, 12), // "colorChanged"
QT_MOC_LITERAL(21, 337, 5), // "color"
QT_MOC_LITERAL(22, 343, 14), // "bearingChanged"
QT_MOC_LITERAL(23, 358, 7), // "bearing"
QT_MOC_LITERAL(24, 366, 11), // "tiltChanged"
QT_MOC_LITERAL(25, 378, 4), // "tilt"
QT_MOC_LITERAL(26, 383, 18), // "fieldOfViewChanged"
QT_MOC_LITERAL(27, 402, 11), // "fieldOfView"
QT_MOC_LITERAL(28, 414, 18), // "minimumTiltChanged"
QT_MOC_LITERAL(29, 433, 11), // "minimumTilt"
QT_MOC_LITERAL(30, 445, 18), // "maximumTiltChanged"
QT_MOC_LITERAL(31, 464, 11), // "maximumTilt"
QT_MOC_LITERAL(32, 476, 25), // "minimumFieldOfViewChanged"
QT_MOC_LITERAL(33, 502, 18), // "minimumFieldOfView"
QT_MOC_LITERAL(34, 521, 25), // "maximumFieldOfViewChanged"
QT_MOC_LITERAL(35, 547, 18), // "maximumFieldOfView"
QT_MOC_LITERAL(36, 566, 17), // "copyrightsChanged"
QT_MOC_LITERAL(37, 584, 15), // "copyrightsImage"
QT_MOC_LITERAL(38, 600, 14), // "copyrightsHtml"
QT_MOC_LITERAL(39, 615, 15), // "mapReadyChanged"
QT_MOC_LITERAL(40, 631, 5), // "ready"
QT_MOC_LITERAL(41, 637, 25), // "mappingManagerInitialized"
QT_MOC_LITERAL(42, 663, 11), // "pluginReady"
QT_MOC_LITERAL(43, 675, 26), // "onSupportedMapTypesChanged"
QT_MOC_LITERAL(44, 702, 27), // "onCameraCapabilitiesChanged"
QT_MOC_LITERAL(45, 730, 22), // "QGeoCameraCapabilities"
QT_MOC_LITERAL(46, 753, 21), // "oldCameraCapabilities"
QT_MOC_LITERAL(47, 775, 42), // "onAttachedCopyrightNoticeVisi..."
QT_MOC_LITERAL(48, 818, 13), // "removeMapItem"
QT_MOC_LITERAL(49, 832, 27), // "QDeclarativeGeoMapItemBase*"
QT_MOC_LITERAL(50, 860, 4), // "item"
QT_MOC_LITERAL(51, 865, 10), // "addMapItem"
QT_MOC_LITERAL(52, 876, 15), // "addMapItemGroup"
QT_MOC_LITERAL(53, 892, 28), // "QDeclarativeGeoMapItemGroup*"
QT_MOC_LITERAL(54, 921, 9), // "itemGroup"
QT_MOC_LITERAL(55, 931, 18), // "removeMapItemGroup"
QT_MOC_LITERAL(56, 950, 13), // "clearMapItems"
QT_MOC_LITERAL(57, 964, 15), // "addMapParameter"
QT_MOC_LITERAL(58, 980, 28), // "QDeclarativeGeoMapParameter*"
QT_MOC_LITERAL(59, 1009, 9), // "parameter"
QT_MOC_LITERAL(60, 1019, 18), // "removeMapParameter"
QT_MOC_LITERAL(61, 1038, 18), // "clearMapParameters"
QT_MOC_LITERAL(62, 1057, 12), // "toCoordinate"
QT_MOC_LITERAL(63, 1070, 8), // "position"
QT_MOC_LITERAL(64, 1079, 14), // "clipToViewPort"
QT_MOC_LITERAL(65, 1094, 14), // "fromCoordinate"
QT_MOC_LITERAL(66, 1109, 21), // "fitViewportToMapItems"
QT_MOC_LITERAL(67, 1131, 28), // "fitViewportToVisibleMapItems"
QT_MOC_LITERAL(68, 1160, 3), // "pan"
QT_MOC_LITERAL(69, 1164, 2), // "dx"
QT_MOC_LITERAL(70, 1167, 2), // "dy"
QT_MOC_LITERAL(71, 1170, 12), // "prefetchData"
QT_MOC_LITERAL(72, 1183, 9), // "clearData"
QT_MOC_LITERAL(73, 1193, 7), // "gesture"
QT_MOC_LITERAL(74, 1201, 24), // "QQuickGeoMapGestureArea*"
QT_MOC_LITERAL(75, 1226, 16), // "minimumZoomLevel"
QT_MOC_LITERAL(76, 1243, 16), // "maximumZoomLevel"
QT_MOC_LITERAL(77, 1260, 13), // "activeMapType"
QT_MOC_LITERAL(78, 1274, 23), // "QDeclarativeGeoMapType*"
QT_MOC_LITERAL(79, 1298, 17), // "supportedMapTypes"
QT_MOC_LITERAL(80, 1316, 40), // "QQmlListProperty<QDeclarative..."
QT_MOC_LITERAL(81, 1357, 6), // "center"
QT_MOC_LITERAL(82, 1364, 8), // "mapItems"
QT_MOC_LITERAL(83, 1373, 15), // "QList<QObject*>"
QT_MOC_LITERAL(84, 1389, 13), // "mapParameters"
QT_MOC_LITERAL(85, 1403, 5), // "error"
QT_MOC_LITERAL(86, 1409, 26), // "QGeoServiceProvider::Error"
QT_MOC_LITERAL(87, 1436, 11), // "errorString"
QT_MOC_LITERAL(88, 1448, 13), // "visibleRegion"
QT_MOC_LITERAL(89, 1462, 9), // "QGeoShape"
QT_MOC_LITERAL(90, 1472, 17), // "copyrightsVisible"
QT_MOC_LITERAL(91, 1490, 8) // "mapReady"

    },
    "QDeclarativeGeoMap\0pluginChanged\0\0"
    "QDeclarativeGeoServiceProvider*\0plugin\0"
    "zoomLevelChanged\0zoomLevel\0centerChanged\0"
    "QGeoCoordinate\0coordinate\0"
    "activeMapTypeChanged\0supportedMapTypesChanged\0"
    "minimumZoomLevelChanged\0maximumZoomLevelChanged\0"
    "mapItemsChanged\0errorChanged\0"
    "copyrightLinkActivated\0link\0"
    "copyrightsVisibleChanged\0visible\0"
    "colorChanged\0color\0bearingChanged\0"
    "bearing\0tiltChanged\0tilt\0fieldOfViewChanged\0"
    "fieldOfView\0minimumTiltChanged\0"
    "minimumTilt\0maximumTiltChanged\0"
    "maximumTilt\0minimumFieldOfViewChanged\0"
    "minimumFieldOfView\0maximumFieldOfViewChanged\0"
    "maximumFieldOfView\0copyrightsChanged\0"
    "copyrightsImage\0copyrightsHtml\0"
    "mapReadyChanged\0ready\0mappingManagerInitialized\0"
    "pluginReady\0onSupportedMapTypesChanged\0"
    "onCameraCapabilitiesChanged\0"
    "QGeoCameraCapabilities\0oldCameraCapabilities\0"
    "onAttachedCopyrightNoticeVisibilityChanged\0"
    "removeMapItem\0QDeclarativeGeoMapItemBase*\0"
    "item\0addMapItem\0addMapItemGroup\0"
    "QDeclarativeGeoMapItemGroup*\0itemGroup\0"
    "removeMapItemGroup\0clearMapItems\0"
    "addMapParameter\0QDeclarativeGeoMapParameter*\0"
    "parameter\0removeMapParameter\0"
    "clearMapParameters\0toCoordinate\0"
    "position\0clipToViewPort\0fromCoordinate\0"
    "fitViewportToMapItems\0"
    "fitViewportToVisibleMapItems\0pan\0dx\0"
    "dy\0prefetchData\0clearData\0gesture\0"
    "QQuickGeoMapGestureArea*\0minimumZoomLevel\0"
    "maximumZoomLevel\0activeMapType\0"
    "QDeclarativeGeoMapType*\0supportedMapTypes\0"
    "QQmlListProperty<QDeclarativeGeoMapType>\0"
    "center\0mapItems\0QList<QObject*>\0"
    "mapParameters\0error\0QGeoServiceProvider::Error\0"
    "errorString\0visibleRegion\0QGeoShape\0"
    "copyrightsVisible\0mapReady"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_QDeclarativeGeoMap[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
      44,   14, // methods
      23,  340, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
      22,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,  234,    2, 0x06 /* Public */,
       5,    1,  237,    2, 0x06 /* Public */,
       7,    1,  240,    2, 0x06 /* Public */,
      10,    0,  243,    2, 0x06 /* Public */,
      11,    0,  244,    2, 0x06 /* Public */,
      12,    0,  245,    2, 0x06 /* Public */,
      13,    0,  246,    2, 0x06 /* Public */,
      14,    0,  247,    2, 0x06 /* Public */,
      15,    0,  248,    2, 0x06 /* Public */,
      16,    1,  249,    2, 0x06 /* Public */,
      18,    1,  252,    2, 0x06 /* Public */,
      20,    1,  255,    2, 0x06 /* Public */,
      22,    1,  258,    2, 0x06 /* Public */,
      24,    1,  261,    2, 0x06 /* Public */,
      26,    1,  264,    2, 0x06 /* Public */,
      28,    1,  267,    2, 0x06 /* Public */,
      30,    1,  270,    2, 0x06 /* Public */,
      32,    1,  273,    2, 0x06 /* Public */,
      34,    1,  276,    2, 0x06 /* Public */,
      36,    1,  279,    2, 0x06 /* Public */,
      36,    1,  282,    2, 0x06 /* Public */,
      39,    1,  285,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
      41,    0,  288,    2, 0x08 /* Private */,
      42,    0,  289,    2, 0x08 /* Private */,
      43,    0,  290,    2, 0x08 /* Private */,
      44,    1,  291,    2, 0x08 /* Private */,
      47,    0,  294,    2, 0x08 /* Private */,

 // methods: name, argc, parameters, tag, flags
      48,    1,  295,    2, 0x02 /* Public */,
      51,    1,  298,    2, 0x02 /* Public */,
      52,    1,  301,    2, 0x02 /* Public */,
      55,    1,  304,    2, 0x02 /* Public */,
      56,    0,  307,    2, 0x02 /* Public */,
      57,    1,  308,    2, 0x02 /* Public */,
      60,    1,  311,    2, 0x02 /* Public */,
      61,    0,  314,    2, 0x02 /* Public */,
      62,    2,  315,    2, 0x02 /* Public */,
      62,    1,  320,    2, 0x22 /* Public | MethodCloned */,
      65,    2,  323,    2, 0x02 /* Public */,
      65,    1,  328,    2, 0x22 /* Public | MethodCloned */,
      66,    0,  331,    2, 0x02 /* Public */,
      67,    0,  332,    2, 0x02 /* Public */,
      68,    2,  333,    2, 0x02 /* Public */,
      71,    0,  338,    2, 0x02 /* Public */,
      72,    0,  339,    2, 0x02 /* Public */,

 // signals: parameters
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void, QMetaType::QReal,    6,
    QMetaType::Void, 0x80000000 | 8,    9,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QString,   17,
    QMetaType::Void, QMetaType::Bool,   19,
    QMetaType::Void, QMetaType::QColor,   21,
    QMetaType::Void, QMetaType::QReal,   23,
    QMetaType::Void, QMetaType::QReal,   25,
    QMetaType::Void, QMetaType::QReal,   27,
    QMetaType::Void, QMetaType::QReal,   29,
    QMetaType::Void, QMetaType::QReal,   31,
    QMetaType::Void, QMetaType::QReal,   33,
    QMetaType::Void, QMetaType::QReal,   35,
    QMetaType::Void, QMetaType::QImage,   37,
    QMetaType::Void, QMetaType::QString,   38,
    QMetaType::Void, QMetaType::Bool,   40,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, 0x80000000 | 45,   46,
    QMetaType::Void,

 // methods: parameters
    QMetaType::Void, 0x80000000 | 49,   50,
    QMetaType::Void, 0x80000000 | 49,   50,
    QMetaType::Void, 0x80000000 | 53,   54,
    QMetaType::Void, 0x80000000 | 53,   54,
    QMetaType::Void,
    QMetaType::Void, 0x80000000 | 58,   59,
    QMetaType::Void, 0x80000000 | 58,   59,
    QMetaType::Void,
    0x80000000 | 8, QMetaType::QPointF, QMetaType::Bool,   63,   64,
    0x80000000 | 8, QMetaType::QPointF,   63,
    QMetaType::QPointF, 0x80000000 | 8, QMetaType::Bool,    9,   64,
    QMetaType::QPointF, 0x80000000 | 8,    9,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int, QMetaType::Int,   69,   70,
    QMetaType::Void,
    QMetaType::Void,

 // properties: name, type, flags
      73, 0x80000000 | 74, 0x00095409,
       4, 0x80000000 | 3, 0x0049510b,
      75, QMetaType::QReal, 0x00495103,
      76, QMetaType::QReal, 0x00495103,
       6, QMetaType::QReal, 0x00495103,
      25, QMetaType::QReal, 0x00495103,
      29, QMetaType::QReal, 0x00495103,
      31, QMetaType::QReal, 0x00495103,
      23, QMetaType::QReal, 0x00495103,
      27, QMetaType::QReal, 0x00495103,
      33, QMetaType::QReal, 0x00495103,
      35, QMetaType::QReal, 0x00495103,
      77, 0x80000000 | 78, 0x0049510b,
      79, 0x80000000 | 80, 0x00495009,
      81, 0x80000000 | 8, 0x0049510b,
      82, 0x80000000 | 83, 0x00495009,
      84, 0x80000000 | 83, 0x00095009,
      85, 0x80000000 | 86, 0x00495009,
      87, QMetaType::QString, 0x00495001,
      88, 0x80000000 | 89, 0x0009510b,
      90, QMetaType::Bool, 0x00495103,
      21, QMetaType::QColor, 0x00495103,
      91, QMetaType::Bool, 0x00495001,

 // properties: notify_signal_id
       0,
       0,
       5,
       6,
       1,
      13,
      15,
      16,
      12,
      14,
      17,
      17,
       3,
       4,
       2,
       7,
       0,
       8,
       8,
       0,
      10,
      11,
      21,

 // enums: name, flags, count, data

 // enum data: key, value

       0        // eod
};

void QDeclarativeGeoMap::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        QDeclarativeGeoMap *_t = static_cast<QDeclarativeGeoMap *>(_o);
        Q_UNUSED(_t)
        switch (_id) {
        case 0: _t->pluginChanged((*reinterpret_cast< QDeclarativeGeoServiceProvider*(*)>(_a[1]))); break;
        case 1: _t->zoomLevelChanged((*reinterpret_cast< qreal(*)>(_a[1]))); break;
        case 2: _t->centerChanged((*reinterpret_cast< const QGeoCoordinate(*)>(_a[1]))); break;
        case 3: _t->activeMapTypeChanged(); break;
        case 4: _t->supportedMapTypesChanged(); break;
        case 5: _t->minimumZoomLevelChanged(); break;
        case 6: _t->maximumZoomLevelChanged(); break;
        case 7: _t->mapItemsChanged(); break;
        case 8: _t->errorChanged(); break;
        case 9: _t->copyrightLinkActivated((*reinterpret_cast< const QString(*)>(_a[1]))); break;
        case 10: _t->copyrightsVisibleChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
        case 11: _t->colorChanged((*reinterpret_cast< const QColor(*)>(_a[1]))); break;
        case 12: _t->bearingChanged((*reinterpret_cast< qreal(*)>(_a[1]))); break;
        case 13: _t->tiltChanged((*reinterpret_cast< qreal(*)>(_a[1]))); break;
        case 14: _t->fieldOfViewChanged((*reinterpret_cast< qreal(*)>(_a[1]))); break;
        case 15: _t->minimumTiltChanged((*reinterpret_cast< qreal(*)>(_a[1]))); break;
        case 16: _t->maximumTiltChanged((*reinterpret_cast< qreal(*)>(_a[1]))); break;
        case 17: _t->minimumFieldOfViewChanged((*reinterpret_cast< qreal(*)>(_a[1]))); break;
        case 18: _t->maximumFieldOfViewChanged((*reinterpret_cast< qreal(*)>(_a[1]))); break;
        case 19: _t->copyrightsChanged((*reinterpret_cast< const QImage(*)>(_a[1]))); break;
        case 20: _t->copyrightsChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
        case 21: _t->mapReadyChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
        case 22: _t->mappingManagerInitialized(); break;
        case 23: _t->pluginReady(); break;
        case 24: _t->onSupportedMapTypesChanged(); break;
        case 25: _t->onCameraCapabilitiesChanged((*reinterpret_cast< const QGeoCameraCapabilities(*)>(_a[1]))); break;
        case 26: _t->onAttachedCopyrightNoticeVisibilityChanged(); break;
        case 27: _t->removeMapItem((*reinterpret_cast< QDeclarativeGeoMapItemBase*(*)>(_a[1]))); break;
        case 28: _t->addMapItem((*reinterpret_cast< QDeclarativeGeoMapItemBase*(*)>(_a[1]))); break;
        case 29: _t->addMapItemGroup((*reinterpret_cast< QDeclarativeGeoMapItemGroup*(*)>(_a[1]))); break;
        case 30: _t->removeMapItemGroup((*reinterpret_cast< QDeclarativeGeoMapItemGroup*(*)>(_a[1]))); break;
        case 31: _t->clearMapItems(); break;
        case 32: _t->addMapParameter((*reinterpret_cast< QDeclarativeGeoMapParameter*(*)>(_a[1]))); break;
        case 33: _t->removeMapParameter((*reinterpret_cast< QDeclarativeGeoMapParameter*(*)>(_a[1]))); break;
        case 34: _t->clearMapParameters(); break;
        case 35: { QGeoCoordinate _r = _t->toCoordinate((*reinterpret_cast< const QPointF(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2])));
            if (_a[0]) *reinterpret_cast< QGeoCoordinate*>(_a[0]) = std::move(_r); }  break;
        case 36: { QGeoCoordinate _r = _t->toCoordinate((*reinterpret_cast< const QPointF(*)>(_a[1])));
            if (_a[0]) *reinterpret_cast< QGeoCoordinate*>(_a[0]) = std::move(_r); }  break;
        case 37: { QPointF _r = _t->fromCoordinate((*reinterpret_cast< const QGeoCoordinate(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2])));
            if (_a[0]) *reinterpret_cast< QPointF*>(_a[0]) = std::move(_r); }  break;
        case 38: { QPointF _r = _t->fromCoordinate((*reinterpret_cast< const QGeoCoordinate(*)>(_a[1])));
            if (_a[0]) *reinterpret_cast< QPointF*>(_a[0]) = std::move(_r); }  break;
        case 39: _t->fitViewportToMapItems(); break;
        case 40: _t->fitViewportToVisibleMapItems(); break;
        case 41: _t->pan((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
        case 42: _t->prefetchData(); break;
        case 43: _t->clearData(); break;
        default: ;
        }
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 2:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<int*>(_a[0]) = -1; break;
            case 0:
                *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QGeoCoordinate >(); break;
            }
            break;
        case 29:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<int*>(_a[0]) = -1; break;
            case 0:
                *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QDeclarativeGeoMapItemGroup* >(); break;
            }
            break;
        case 30:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<int*>(_a[0]) = -1; break;
            case 0:
                *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QDeclarativeGeoMapItemGroup* >(); break;
            }
            break;
        case 37:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<int*>(_a[0]) = -1; break;
            case 0:
                *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QGeoCoordinate >(); break;
            }
            break;
        case 38:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<int*>(_a[0]) = -1; break;
            case 0:
                *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QGeoCoordinate >(); break;
            }
            break;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            typedef void (QDeclarativeGeoMap::*_t)(QDeclarativeGeoServiceProvider * );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::pluginChanged)) {
                *result = 0;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(qreal );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::zoomLevelChanged)) {
                *result = 1;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(const QGeoCoordinate & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::centerChanged)) {
                *result = 2;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::activeMapTypeChanged)) {
                *result = 3;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::supportedMapTypesChanged)) {
                *result = 4;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::minimumZoomLevelChanged)) {
                *result = 5;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::maximumZoomLevelChanged)) {
                *result = 6;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::mapItemsChanged)) {
                *result = 7;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::errorChanged)) {
                *result = 8;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(const QString & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::copyrightLinkActivated)) {
                *result = 9;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(bool );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::copyrightsVisibleChanged)) {
                *result = 10;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(const QColor & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::colorChanged)) {
                *result = 11;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(qreal );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::bearingChanged)) {
                *result = 12;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(qreal );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::tiltChanged)) {
                *result = 13;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(qreal );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::fieldOfViewChanged)) {
                *result = 14;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(qreal );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::minimumTiltChanged)) {
                *result = 15;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(qreal );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::maximumTiltChanged)) {
                *result = 16;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(qreal );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::minimumFieldOfViewChanged)) {
                *result = 17;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(qreal );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::maximumFieldOfViewChanged)) {
                *result = 18;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(const QImage & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::copyrightsChanged)) {
                *result = 19;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(const QString & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::copyrightsChanged)) {
                *result = 20;
                return;
            }
        }
        {
            typedef void (QDeclarativeGeoMap::*_t)(bool );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&QDeclarativeGeoMap::mapReadyChanged)) {
                *result = 21;
                return;
            }
        }
    } else if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 14:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QGeoCoordinate >(); break;
        case 19:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QGeoShape >(); break;
        case 16:
        case 15:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QList<QObject*> >(); break;
        case 0:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QQuickGeoMapGestureArea* >(); break;
        }
    }

#ifndef QT_NO_PROPERTIES
    else if (_c == QMetaObject::ReadProperty) {
        QDeclarativeGeoMap *_t = static_cast<QDeclarativeGeoMap *>(_o);
        Q_UNUSED(_t)
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QQuickGeoMapGestureArea**>(_v) = _t->gesture(); break;
        case 1: *reinterpret_cast< QDeclarativeGeoServiceProvider**>(_v) = _t->plugin(); break;
        case 2: *reinterpret_cast< qreal*>(_v) = _t->minimumZoomLevel(); break;
        case 3: *reinterpret_cast< qreal*>(_v) = _t->maximumZoomLevel(); break;
        case 4: *reinterpret_cast< qreal*>(_v) = _t->zoomLevel(); break;
        case 5: *reinterpret_cast< qreal*>(_v) = _t->tilt(); break;
        case 6: *reinterpret_cast< qreal*>(_v) = _t->minimumTilt(); break;
        case 7: *reinterpret_cast< qreal*>(_v) = _t->maximumTilt(); break;
        case 8: *reinterpret_cast< qreal*>(_v) = _t->bearing(); break;
        case 9: *reinterpret_cast< qreal*>(_v) = _t->fieldOfView(); break;
        case 10: *reinterpret_cast< qreal*>(_v) = _t->minimumFieldOfView(); break;
        case 11: *reinterpret_cast< qreal*>(_v) = _t->maximumFieldOfView(); break;
        case 12: *reinterpret_cast< QDeclarativeGeoMapType**>(_v) = _t->activeMapType(); break;
        case 13: *reinterpret_cast< QQmlListProperty<QDeclarativeGeoMapType>*>(_v) = _t->supportedMapTypes(); break;
        case 14: *reinterpret_cast< QGeoCoordinate*>(_v) = _t->center(); break;
        case 15: *reinterpret_cast< QList<QObject*>*>(_v) = _t->mapItems(); break;
        case 16: *reinterpret_cast< QList<QObject*>*>(_v) = _t->mapParameters(); break;
        case 17: *reinterpret_cast< QGeoServiceProvider::Error*>(_v) = _t->error(); break;
        case 18: *reinterpret_cast< QString*>(_v) = _t->errorString(); break;
        case 19: *reinterpret_cast< QGeoShape*>(_v) = _t->visibleRegion(); break;
        case 20: *reinterpret_cast< bool*>(_v) = _t->copyrightsVisible(); break;
        case 21: *reinterpret_cast< QColor*>(_v) = _t->color(); break;
        case 22: *reinterpret_cast< bool*>(_v) = _t->mapReady(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        QDeclarativeGeoMap *_t = static_cast<QDeclarativeGeoMap *>(_o);
        Q_UNUSED(_t)
        void *_v = _a[0];
        switch (_id) {
        case 1: _t->setPlugin(*reinterpret_cast< QDeclarativeGeoServiceProvider**>(_v)); break;
        case 2: _t->setMinimumZoomLevel(*reinterpret_cast< qreal*>(_v)); break;
        case 3: _t->setMaximumZoomLevel(*reinterpret_cast< qreal*>(_v)); break;
        case 4: _t->setZoomLevel(*reinterpret_cast< qreal*>(_v)); break;
        case 5: _t->setTilt(*reinterpret_cast< qreal*>(_v)); break;
        case 6: _t->setMinimumTilt(*reinterpret_cast< qreal*>(_v)); break;
        case 7: _t->setMaximumTilt(*reinterpret_cast< qreal*>(_v)); break;
        case 8: _t->setBearing(*reinterpret_cast< qreal*>(_v)); break;
        case 9: _t->setFieldOfView(*reinterpret_cast< qreal*>(_v)); break;
        case 10: _t->setMinimumFieldOfView(*reinterpret_cast< qreal*>(_v)); break;
        case 11: _t->setMaximumFieldOfView(*reinterpret_cast< qreal*>(_v)); break;
        case 12: _t->setActiveMapType(*reinterpret_cast< QDeclarativeGeoMapType**>(_v)); break;
        case 14: _t->setCenter(*reinterpret_cast< QGeoCoordinate*>(_v)); break;
        case 19: _t->setVisibleRegion(*reinterpret_cast< QGeoShape*>(_v)); break;
        case 20: _t->setCopyrightsVisible(*reinterpret_cast< bool*>(_v)); break;
        case 21: _t->setColor(*reinterpret_cast< QColor*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    }
#endif // QT_NO_PROPERTIES
}

static const QMetaObject * const qt_meta_extradata_QDeclarativeGeoMap[] = {
        &QGeoServiceProvider::staticMetaObject,
    nullptr
};

const QMetaObject QDeclarativeGeoMap::staticMetaObject = {
    { &QQuickItem::staticMetaObject, qt_meta_stringdata_QDeclarativeGeoMap.data,
      qt_meta_data_QDeclarativeGeoMap,  qt_static_metacall, qt_meta_extradata_QDeclarativeGeoMap, nullptr}
};


const QMetaObject *QDeclarativeGeoMap::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QDeclarativeGeoMap::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_QDeclarativeGeoMap.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "org.qt-project.Qt.QQmlParserStatus"))
        return static_cast< QQmlParserStatus*>(this);
    return QQuickItem::qt_metacast(_clname);
}

int QDeclarativeGeoMap::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QQuickItem::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 44)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 44;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 44)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 44;
    }
#ifndef QT_NO_PROPERTIES
   else if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 23;
    } else if (_c == QMetaObject::QueryPropertyDesignable) {
        _id -= 23;
    } else if (_c == QMetaObject::QueryPropertyScriptable) {
        _id -= 23;
    } else if (_c == QMetaObject::QueryPropertyStored) {
        _id -= 23;
    } else if (_c == QMetaObject::QueryPropertyEditable) {
        _id -= 23;
    } else if (_c == QMetaObject::QueryPropertyUser) {
        _id -= 23;
    }
#endif // QT_NO_PROPERTIES
    return _id;
}

// SIGNAL 0
void QDeclarativeGeoMap::pluginChanged(QDeclarativeGeoServiceProvider * _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void QDeclarativeGeoMap::zoomLevelChanged(qreal _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void QDeclarativeGeoMap::centerChanged(const QGeoCoordinate & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}

// SIGNAL 3
void QDeclarativeGeoMap::activeMapTypeChanged()
{
    QMetaObject::activate(this, &staticMetaObject, 3, nullptr);
}

// SIGNAL 4
void QDeclarativeGeoMap::supportedMapTypesChanged()
{
    QMetaObject::activate(this, &staticMetaObject, 4, nullptr);
}

// SIGNAL 5
void QDeclarativeGeoMap::minimumZoomLevelChanged()
{
    QMetaObject::activate(this, &staticMetaObject, 5, nullptr);
}

// SIGNAL 6
void QDeclarativeGeoMap::maximumZoomLevelChanged()
{
    QMetaObject::activate(this, &staticMetaObject, 6, nullptr);
}

// SIGNAL 7
void QDeclarativeGeoMap::mapItemsChanged()
{
    QMetaObject::activate(this, &staticMetaObject, 7, nullptr);
}

// SIGNAL 8
void QDeclarativeGeoMap::errorChanged()
{
    QMetaObject::activate(this, &staticMetaObject, 8, nullptr);
}

// SIGNAL 9
void QDeclarativeGeoMap::copyrightLinkActivated(const QString & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 9, _a);
}

// SIGNAL 10
void QDeclarativeGeoMap::copyrightsVisibleChanged(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 10, _a);
}

// SIGNAL 11
void QDeclarativeGeoMap::colorChanged(const QColor & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 11, _a);
}

// SIGNAL 12
void QDeclarativeGeoMap::bearingChanged(qreal _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 12, _a);
}

// SIGNAL 13
void QDeclarativeGeoMap::tiltChanged(qreal _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 13, _a);
}

// SIGNAL 14
void QDeclarativeGeoMap::fieldOfViewChanged(qreal _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 14, _a);
}

// SIGNAL 15
void QDeclarativeGeoMap::minimumTiltChanged(qreal _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 15, _a);
}

// SIGNAL 16
void QDeclarativeGeoMap::maximumTiltChanged(qreal _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 16, _a);
}

// SIGNAL 17
void QDeclarativeGeoMap::minimumFieldOfViewChanged(qreal _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 17, _a);
}

// SIGNAL 18
void QDeclarativeGeoMap::maximumFieldOfViewChanged(qreal _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 18, _a);
}

// SIGNAL 19
void QDeclarativeGeoMap::copyrightsChanged(const QImage & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 19, _a);
}

// SIGNAL 20
void QDeclarativeGeoMap::copyrightsChanged(const QString & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 20, _a);
}

// SIGNAL 21
void QDeclarativeGeoMap::mapReadyChanged(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 21, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE
